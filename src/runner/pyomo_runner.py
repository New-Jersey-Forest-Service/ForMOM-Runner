'''
Pyomo Optimizer

This program takes .dat inputs generated by the
csv_to_dat converter and runs them in a linear
optimization model using pyomo and the glpk
solver.

Code adapted from "Named Generic Abstract Solver"
demonstrated by Michael Gorbunov 2022;
Allows sets' indicies to be named

New Jersey Forest Service 2022
'''
import sys
from typing import Union
import pyomo.environ as pyo
import pyomo.opt as opt

import runner.text as text


# In Python2, integer divisions truncate values (1/2 = 0 instead of 0.5)
# which breaks the solver. Either way, we should be using python3
if (sys.version[0] != '3'):
	print("You are not using python 3, so this will fail")
	sys.exit(1)


# Really this abstract model should be built once at init
# instead of by calling a function, but the overhead is so low
# it doesn't really matter.
def _buildAbstractModel () -> pyo.AbstractModel:
	# Build the model
	model = pyo.AbstractModel()
	model.index_vars = pyo.Set()
	model.index_le_consts = pyo.Set()
	model.index_ge_consts = pyo.Set()
	model.index_eq_consts = pyo.Set()

	model.x = pyo.Var(model.index_vars, domain=pyo.NonNegativeReals)

	# These guys are read from input.dat
	model.vec_objective = pyo.Param(model.index_vars)

	model.mat_le = pyo.Param(model.index_le_consts, model.index_vars)
	model.vec_le = pyo.Param(model.index_le_consts)

	model.mat_ge = pyo.Param(model.index_ge_consts, model.index_vars)
	model.vec_ge = pyo.Param(model.index_ge_consts)

	model.mat_eq = pyo.Param(model.index_eq_consts, model.index_vars)
	model.vec_eq = pyo.Param(model.index_eq_consts)

	#Defining the actual functions
	def obj_function(_model):
		return pyo.summation(_model.vec_objective, _model.x)

	def le_mat_rule (_model, k):
		return sum(_model.mat_le[k, i] * _model.x[i] for i in _model.index_vars) <= _model.vec_le[k]

	def ge_mat_rule (_model, k):
		return sum(_model.mat_ge[k, i] * _model.x[i] for i in _model.index_vars) >= _model.vec_ge[k]

	def eq_mat_rule (_model, k):
		return sum(_model.mat_eq[k, i] * _model.x[i] for i in _model.index_vars) == _model.vec_eq[k]

	model.OBJ = pyo.Objective(rule=obj_function, sense=pyo.maximize)
	model.GEConstraint = pyo.Constraint(model.index_ge_consts, rule=ge_mat_rule)
	model.LEConstraint = pyo.Constraint(model.index_le_consts, rule=le_mat_rule)
	model.EQConstraint = pyo.Constraint(model.index_eq_consts, rule=eq_mat_rule)

	return model


def loadPyomoModelFromFinalModel (datadict: dict):
	model = _buildAbstractModel()
	instance = model.create_instance(data=datadict)
	instance.dual = pyo.Suffix(direction=pyo.Suffix.IMPORT_EXPORT)
	return instance


def loadPyomoModelFromDat (datFilepath: str) -> pyo.ConcreteModel:
	model = _buildAbstractModel()

	# Now read data file
	instance = model.create_instance(filename=datFilepath)

	# Add duals (shadow cost) info 
	# I have no idea why duals are the same as shadow costs, but they are
	instance.dual = pyo.Suffix(direction=pyo.Suffix.IMPORT_EXPORT)

	return instance


def solveConcreteModel (instance: pyo.ConcreteModel, verboseToConsole: bool=False) -> Union[pyo.ConcreteModel, opt.SolverResults]:
	'''
		Solves the passed in modle (mutates it), and returns
		the concrete model + the solver results
	'''
	solver = pyo.SolverFactory('glpk')

	# Now optimize
	results = solver.solve(instance, tee=verboseToConsole)

	return instance, results








if __name__ == '__main__':
	filepath = '/home/velcro/Documents/Professional/NJDEP/TechWork/ForMOM-Runner/sample-data/SLmonthly1_out.dat'
	instance = loadPyomoModelFromDat(filepath)
	instance, res = solveConcreteModel(instance)
	resStr = text.exportRunText(instance, res)

	print(resStr)

